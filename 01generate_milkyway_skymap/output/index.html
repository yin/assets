<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Environment Map preview</title>
    <style>
      html, body {
        padding: 0;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script id="vertexShader" type="x-shader/x-vertex">
			precision mediump float;
			precision mediump int;
			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional
			attribute vec3 position;
			attribute vec4 normal;
			varying vec3 vPosition;
			varying vec4 vNormal;
			void main()	{
				vPosition = position;
				vNormal = normal;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
    
			precision mediump float;
			precision mediump int;
			uniform float time;
			varying vec3 vPosition;
			varying vec4 vNormal;
			void main()	{
				vec4 color = vec4( 0.5, 1.0, 0.0, 1.0 );
				color.r += sin( vNormal.y * 10.0 + time ) * 0.5;
				gl_FragColor = color;
			}
    </script>
    
    <script src="three.min.js"></script>
    <script>


        // create and set up the scene, etc
        var width = window.innerWidth;
        var height = window.innerHeight;
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(35, width / height, 1, 1500);
        var renderer = new THREE.WebGLRenderer({antialias:true});
        var time = 0;
        var ORIGIN = new THREE.Vector3();

        // urls of the images,
        // one per half axis
        var urls = [
              'pos-x.jpg',
              'neg-x.jpg',
              'pos-y.jpg',
              'neg-y.jpg',
              'pos-z.jpg',
              'neg-z.jpg'
            ];

        // wrap it up into the object that we need
        var cubemap = (new THREE.CubeTextureLoader()).load(urls);
        
      
        // set the format, likely RGB
        // unless you've gone crazy
        cubemap.format = THREE.RGBFormat;

        scene.background = cubemap;

        var ambient = new THREE.AmbientLight( 0xffffff );
        scene.add(ambient);

        var pointLight = new THREE.PointLight( 0xffffff, 2 );
        scene.add( pointLight );

        var shaderMaterial = new THREE.RawShaderMaterial( {
          uniforms: {
            time: { value: 1.0 }
          },
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
          side: THREE.DoubleSide,
          transparent: true
        } );
      
        var torus = new THREE.Mesh(
          new THREE.SphereGeometry(60, 20, 20),
          shaderMaterial
        );

        scene.add(torus);
        scene.add(camera);

        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        function animate() {
          var time = performance.now();
          var object = scene.children[ 2 ];
          object.rotation.y = time * 0.0005;
          object.material.uniforms.time.value = time * 0.005;
          
          camera.position.x = Math.sin(time * 0.0005) * 400;
          camera.position.z = Math.cos(time * 0.0005) * 400;
          camera.lookAt(ORIGIN);

          renderer.render(scene,camera);
          requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

    </script>
  </body>
</html>
